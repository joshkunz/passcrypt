#!/usr/bin/env python

"""
passcrypt - hide in plain sight

    passcrypt is a simple key-value style password
    storage mechanism that keeps password values in
    a encrypted (through various means) file. It was
    written to be used in conjuntion with the {dotfile manager}
    as a simple way of keeping passwords with
    configuration files in a secure way.
"""
import cPickle
from Crypto.Cipher import DES3, AES, Blowfish, blockalgo
from Crypto.Util import Counter
import hashlib
import os

class CryptFile(object):
    """Basic methods for all of the file-types"""

    @classmethod
    def is_file_like(cls, object):
        """Check to see if an object supports
        basic file-like operations"""
        return all((hasattr(object, "read"),
                    hasattr(object, "write"),
                    hasattr(object, "tell"),
                    hasattr(object, "seek"),
                    hasattr(object, "close")))

    def __init__(self, file_name_or_obj):
        if self.is_file_like(file_name_or_obj):
            self._file = file_name_or_obj
        else:
            self._file = open(file_name_or_obj)

class PasswordCryptFile(CryptFile):
    """Write and INIT operations for 'password' style
    ciphers"""

    def __init__(self, file_name_or_obj, passphrase):
        super(PasswordCryptFile, self).__init__(file_name_or_obj)
        self._passphrase = hashlib.sha256(passphrase).hexdigest()
        self._crypt = self.new_cipher()

    def new_cipher(self):
        return self.get_cipher(self._passphrase[:self.get_key_size()])

    def read(self, size=None):
        if size is None:
            ciphertext = self._file.read()
        else:
            ciphertext = self._file.read(size)
        return self._crypt.decrypt(ciphertext)

    def readline(self):
        buffer = ""
        _in = self.read(1)
        while _in and _in != "\n":
            buffer += _in
            _in = self.read(1)
        return buffer

    def is_empty(self):
        """An empty file checker, to avoid needless seeks to the
        end of the file"""
        pos = self._file.tell()
        self.seek(0, 2)
        r = self._file.tell() == 0
        self.seek(pos, 0)
        return r

    def seek(self, to, whence):
        """Waring this is a very ineffeciant method,
        ciphers are not made to be able to move backwards through
        (that would really kind of defeat the purpose) so ever seek
        requires a read to the seeked-to, position"""
        self._file.seek(to, whence)
        pos = self._file.tell()
        self._file.seek(0, 0)
        self._crypt = self.new_cipher()
        self.read(pos)

    def write(self, plaintext):
        return self._file.write(self._crypt.encrypt(plaintext))

    def tell(self, *args, **kwargs):
        return self._file.tell(*args, **kwargs)
    
    def close(self):
        return self._file.close()

class PKSAEPFile(CryptFile):
    """Read/write PKS-AEP encrypted files"""

    def __init__(self, file_name_or_obj, keyfile=None):
        super(PKSAEPFile, self).__init__(file_name_or_obj)
        if keyfile is not None and self.is_file_like(keyfile):
            self._keyfile = keyfile
        elif keyfile is not None:
            self._keyfile = open(keyfile, 'rb')
        else: self._keyfile = None

class BlowfishFile(PasswordCryptFile):
    """Read/write Blowfish encryped files"""

    def get_key_size(self):
        return 56

    def get_cipher(self, key):
        # 8 byte counter
        self._counter = Counter.new(64)
        return Blowfish.new(key, 
                            Blowfish.MODE_CTR, 
                            counter=self._counter)


class AESFile(PasswordCryptFile):
    """Read/write AES encrypted files"""

    def get_key_size(self):
        return 32

    def get_cipher(self, key):
        # 16 byte counter
        self._counter = Counter.new(16*8)
        return AES.new(key,
                       AES.MODE_CTR,
                       counter=self._counter)

class DES3File(PasswordCryptFile):
    """Read/write DES3 encrypted files"""

    def get_key_size(self): return 16

    def get_cipher(self, key):
        # * byte counter (8*8 bits)
        self._counter = Counter.new(8*8)
        return DES3.new(key,
                        DES3.MODE_CTR,
                        counter=self._counter)

class EncryptedShelf(object):
    """Simple shelf wrapper for working with a file obj"""

    def get_file(self, mode='r'):
        return self._writer(open(self._filename, mode), self._passphrase)

    def __init__(self, writer, filename, passphrase, protocol=0):
        self._writer = writer
        self._filename = filename
        self._passphrase = passphrase

        if os.path.exists(filename):
            file = self.get_file()
            # unfortunatly, proper unpickling from .load is not
            # working currently
            self._dict = cPickle.loads(file.read())
            file.close()
        else:
            self._dict = {}

        self._protocol = protocol

    def __setitem__(self, key, value):
        self._dict[key] = value

    def __getitem__(self, key):
        return self._dict[key]

    def __delitem__(self, key):
        del self._dict[key]

    def sync(self):
        file = self.get_file(mode='w')
        cPickle.dump(self._dict, file, protocol=self._protocol)
        file.close()

    def close(self):
        """Alias of sync"""
        self.sync()

if __name__ == "__main__":
    """Main program"""
    import argparse
